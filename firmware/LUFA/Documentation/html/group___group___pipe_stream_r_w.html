<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>LUFA (Formerly MyUSB) Library: Read/Write of Multi-Byte Streams</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">LUFA (Formerly MyUSB) Library&#160;<span id="projectnumber">100807</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('group___group___pipe_stream_r_w.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Read/Write of Multi-Byte Streams</h1>  </div>
<div class="ingroups"><a class="el" href="group___group___pipe_management.html">Pipe Management</a> &#124; <a class="el" href="group___group___pipe_r_w.html">Pipe Data Reading and Writing</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#gadf35696d8545a0f022a90f7983bc75ee">Pipe_Discard_Stream</a> (uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#gac89d778832d3bfe503685517e210f35f">Pipe_Write_Stream_LE</a> (const void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#ga9b7c9bcd2a604eedb8c5c199caa119e1">Pipe_Write_EStream_LE</a> (const void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#ga7bf3dbc412beb4a18bfdd40f747f8913">Pipe_Write_PStream_LE</a> (const void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#gab90b21258cec85987fe2ba3416fb265e">Pipe_Write_Stream_BE</a> (const void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#ga10702ce325b4ec8fd9020b385d13e70f">Pipe_Write_EStream_BE</a> (const void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#ga941bca733dd11f9ca5564c1cfee8d056">Pipe_Write_PStream_BE</a> (const void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#gae5c53ac73bff84efe6edb8f472148f51">Pipe_Read_Stream_LE</a> (void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#gad2e8decbcc325bf261cdbf6df242c05f">Pipe_Read_EStream_LE</a> (void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#gab012a699ff5dc5e1a2a1c5f1106c2cab">Pipe_Read_Stream_BE</a> (void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___group___pipe_stream_r_w.html#ga9e84e1515bdc2030be23501a5043c8a2">Pipe_Read_EStream_BE</a> (void *Buffer, uint16_t Length, <a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a> Callback) ATTR_NON_NULL_PTR_ARG(1)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Functions, macros, variables, enums and types related to data reading and writing of data streams from and to pipes. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gadf35696d8545a0f022a90f7983bc75ee"></a><!-- doxytag: member="Pipe.h::Pipe_Discard_Stream" ref="gadf35696d8545a0f022a90f7983bc75ee" args="(uint16_t Length, StreamCallbackPtr_t Callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Discard_Stream </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads and discards the given number of bytes from the pipe, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the device via the <a class="el" href="group___group___pipe_packet_management.html#ga2e328f96f51a22f8af51995b8cc1a351">Pipe_ClearIN()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="group___group___stream_callbacks.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<p>The pipe token is set automatically, thus this can be used on bi-directional pipes directly without having to explicitly change the data direction with a call to <a class="el" href="group___group___pipe_management.html#gab2c5e16a372b1ccbfea35296ec3fe400">Pipe_SetPipeToken()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to send via the currently selected pipe. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9e84e1515bdc2030be23501a5043c8a2"></a><!-- doxytag: member="Pipe.h::Pipe_Read_EStream_BE" ref="ga9e84e1515bdc2030be23501a5043c8a2" args="(void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Read_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___pipe_stream_r_w.html#gab012a699ff5dc5e1a2a1c5f1106c2cab">Pipe_Read_Stream_BE()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gad2e8decbcc325bf261cdbf6df242c05f"></a><!-- doxytag: member="Pipe.h::Pipe_Read_EStream_LE" ref="gad2e8decbcc325bf261cdbf6df242c05f" args="(void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Read_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___pipe_stream_r_w.html#gae5c53ac73bff84efe6edb8f472148f51">Pipe_Read_Stream_LE()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gab012a699ff5dc5e1a2a1c5f1106c2cab"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Stream_BE" ref="gab012a699ff5dc5e1a2a1c5f1106c2cab" args="(void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Read_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes from the pipe into the given buffer in big endian, sending full packets to the device as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="group___group___pipe_packet_management.html#ga2e328f96f51a22f8af51995b8cc1a351">Pipe_ClearIN()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="group___group___stream_callbacks.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<p>The pipe token is set automatically, thus this can be used on bi-directional pipes directly without having to explicitly change the data direction with a call to <a class="el" href="group___group___pipe_management.html#gab2c5e16a372b1ccbfea35296ec3fe400">Pipe_SetPipeToken()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gae5c53ac73bff84efe6edb8f472148f51"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Stream_LE" ref="gae5c53ac73bff84efe6edb8f472148f51" args="(void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Read_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reads the given number of bytes from the pipe into the given buffer in little endian, sending full packets to the device as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="group___group___pipe_packet_management.html#ga2e328f96f51a22f8af51995b8cc1a351">Pipe_ClearIN()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="group___group___stream_callbacks.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<p>The pipe token is set automatically, thus this can be used on bi-directional pipes directly without having to explicitly change the data direction with a call to <a class="el" href="group___group___pipe_management.html#gab2c5e16a372b1ccbfea35296ec3fe400">Pipe_SetPipeToken()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to write to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga10702ce325b4ec8fd9020b385d13e70f"></a><!-- doxytag: member="Pipe.h::Pipe_Write_EStream_BE" ref="ga10702ce325b4ec8fd9020b385d13e70f" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Write_EStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___pipe_stream_r_w.html#gab90b21258cec85987fe2ba3416fb265e">Pipe_Write_Stream_BE()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b7c9bcd2a604eedb8c5c199caa119e1"></a><!-- doxytag: member="Pipe.h::Pipe_Write_EStream_LE" ref="ga9b7c9bcd2a604eedb8c5c199caa119e1" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Write_EStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>EEPROM buffer source version of <a class="el" href="group___group___pipe_stream_r_w.html#gac89d778832d3bfe503685517e210f35f">Pipe_Write_Stream_LE()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga941bca733dd11f9ca5564c1cfee8d056"></a><!-- doxytag: member="Pipe.h::Pipe_Write_PStream_BE" ref="ga941bca733dd11f9ca5564c1cfee8d056" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Write_PStream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="group___group___pipe_stream_r_w.html#gab90b21258cec85987fe2ba3416fb265e">Pipe_Write_Stream_BE()</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7bf3dbc412beb4a18bfdd40f747f8913"></a><!-- doxytag: member="Pipe.h::Pipe_Write_PStream_LE" ref="ga7bf3dbc412beb4a18bfdd40f747f8913" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Write_PStream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>FLASH buffer source version of <a class="el" href="group___group___pipe_stream_r_w.html#gac89d778832d3bfe503685517e210f35f">Pipe_Write_Stream_LE()</a>.</p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>The FLASH data must be located in the first 64KB of FLASH for this function to work correctly.</dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gab90b21258cec85987fe2ba3416fb265e"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Stream_BE" ref="gab90b21258cec85987fe2ba3416fb265e" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Write_Stream_BE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the given number of bytes to the pipe from the given buffer in big endian, sending full packets to the device as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="group___group___pipe_packet_management.html#ga7c2917adea8f75348d14d115b753bfa0">Pipe_ClearOUT()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="group___group___stream_callbacks.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<p>The pipe token is set automatically, thus this can be used on bi-directional pipes directly without having to explicitly change the data direction with a call to <a class="el" href="group___group___pipe_management.html#gab2c5e16a372b1ccbfea35296ec3fe400">Pipe_SetPipeToken()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
<a class="anchor" id="gac89d778832d3bfe503685517e210f35f"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Stream_LE" ref="gac89d778832d3bfe503685517e210f35f" args="(const void *Buffer, uint16_t Length, StreamCallbackPtr_t Callback) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Write_Stream_LE </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___group___stream_callbacks.html#ga55fdd4cd655b89d3964f1205996eaf6f">StreamCallbackPtr_t</a>&#160;</td>
          <td class="paramname"><em>Callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Writes the given number of bytes to the pipe from the given buffer in little endian, sending full packets to the device as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="group___group___pipe_packet_management.html#ga7c2917adea8f75348d14d115b753bfa0">Pipe_ClearOUT()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.</p>
<p>The callback routine should be created according to the information in <a class="el" href="group___group___stream_callbacks.html">Endpoint and Pipe Stream Callbacks</a>. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter omitted.</p>
<p>The pipe token is set automatically, thus this can be used on bi-directional pipes directly without having to explicitly change the data direction with a call to <a class="el" href="group___group___pipe_management.html#gab2c5e16a372b1ccbfea35296ec3fe400">Pipe_SetPipeToken()</a>.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">Buffer</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Length</td><td>Number of bytes to read for the currently selected pipe into the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Callback</td><td>Name of a callback routine to call between successive USB packet transfers, NULL if no callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A value from the <a class="el" href="group___group___pipe_r_w.html#gab83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> enum. </dd></dl>

</div>
</div>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="footer">Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


</body>
</html>
